<html>

<head>
  <meta charset="UTF-8">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <title>Project 2 Final</title>

  <style>
    .center {
      text-align: center;
      color: rgb(84, 82, 82);
    }

    .gridlines line {
      stroke: #bbb;
      stroke-width: 1px;
    }

    .gridlines .domain {
      stroke: none;
    }

    g.mouseover rect {
      fill: white;
      stroke: black;
      stroke-width: 1px;
    }

    g.mouseover text {
      font-family: Arial, sans-serif;
    }

    g.mouseover text:first-child {
      font-weight: bold;
    }

    .outline_countries {
      stroke: black;
      stroke-width: 1px;
      fill: none;
    }
  </style>
</head>

<body>
  <h1>Project 2</h1>
  <h2>Seonghee Lee (sl994), Christy Song (cs966), Lydia Kim (lmk225), Sandy Jiang (sj458)</h2>

  <div class="center">
    <h3>1. General Exploration with Topography Map</h3>
    <p>i. The topography map can show different shades of a particular color for
      each country to represent their happiness ranking from the dataset. <br>
      ii. When a specific country is hovered over or selected, it can be outlined
      and we can provide information on their GDP and other information such as the MBTI distributions (e.g. distributed
      bar graph, horizontal bar graphs, ).</p>

    <strong>Visualization 1: General Exploration with Topography Map</strong><br>
    <svg id="choropleth" height="500" width="1000" style="margin:20px; border:1px solid lightgrey" fill = "gray"></svg>

    <h3>2. GDP of Countries sorted by MBTI</h3>
    <div id="legend"></div>
    <p style="text-align: start;">i. The bar graph would show the gdp distribution by country <br>
      ii. When the user clicks on a MBTI character, bar graphs are resorted by country with the largest distribution of
      that mbti to the least <br>
      iii. When the user hovers over each of the graph points (countries), a tooltip shows the distribution of the MBTI
      of
      that country. <br>
      iv. MBTI Characters</p>
    <strong>Visualization 2: GDP of Countries by each MBTI distribution</strong><br>
    <div id="mbtiSelect" style="font-size: 30px;"></div>
    <div style="display: flex;">
      <svg id='viz2' width="800" height="600" style="margin:20px;margin-left: 50px;"></svg>
      <div id="button-bar" style="width: 500px; margin-left: 30px;"> </div>
    </div>

    <script>
      const svg1 = d3.select("#choropleth");
      const width1 = svg1.attr("width");
      const height1 = svg1.attr("height");
      const margin1 = { top: 20, right: 20, bottom: 20, left: 20 };
      const mapWidth1 = width1 - margin1.left - margin1.right;
      const mapHeight1 = height1 - margin1.top - margin1.bottom;
      const map1 = svg1.append("g")
        .attr("transform", "translate(" + margin1.left + "," + margin1.top + ")");

      const svg2 = d3.select("svg#viz2");
      const width2 = svg2.attr("width");
      const height2 = svg2.attr("height");
      const margin2 = { top: 5, right: 5, bottom: 20, left: 35 };
      const chartWidth2 = width2 - margin2.left;
      const chartHeight2 = height2 - margin2.bottom;
      let chartArea2 = svg2.append("g").attr('id', 'chartarea2')
        .attr("transform", `translate(${margin2.left}, ${margin2.top})`);

      const requestData = async function () {
        // load all data
        const happiness_data = await d3.csv("./data/world_happiness.csv");
        let mbti_data = await d3.csv('./data/mbti_countries.csv');
        console.log(mbti_data);
        const gdp_data = await d3.csv('./data/gdp_countries.csv');
        console.log(gdp_data);
        const world = await d3.json("./data/countries-110m.json");
        console.log(world);
        const mbti_keys = ['ENFJ', 'ENFP', 'ENTJ', 'ENTP', 'ESFJ', 'ESFP', 'ESTJ', 'ESTP', 'INFJ', 'INFP', 'INTJ', 'INTP', 'ISFJ', 'ISFP', 'ISTJ', 'ISTP'];

        // mbti_data: convert distribution to numbers & add -A and -T of same type
        mbti_data.forEach((d, i) => {
          mbti_keys.forEach((mbti, mbti_i) => {
            d[mbti + '-A'] = Number(d[mbti + '-A']);
            d[mbti + '-T'] = Number(d[mbti + '-T']);
            d[mbti] = d[mbti + '-A'] + d[mbti + '-T'];
          });
        });
        let del_countries = ['Montenegro', 'Myanmar']

        mbti_data = mbti_data.filter((d) => {
          return !(del_countries.includes(d['Country']));
        });

        // gdp_data: convert gdp to number
        gdp_data.forEach((d, i) => {
          d['Country'] = d['Country'].trim();
          if (d['Country'] == 'Korea, South') {
            d['Country'] = 'South Korea'
          } else if (d['Country'] == 'Antigua & Barbuda') {
            d['Country'] = 'Antigua and Barbuda'
          } else if (d['Country'] == 'Bosnia & Herzegovina') {
            d['Country'] = 'Bosnia and Herzegovina'
          } else if (d['Country'] == 'Bahamas, The') {
            d['Country'] = 'Bahamas'
          } else if (d['Country'] == 'Congo, Dem. Rep.') {
            d['Country'] = 'Congo (Kinshasa)'
          } else if (d['Country'] == 'Congo, Repub. of the') {
            d['Country'] = 'Congo'
          } else if (d['Country'] == 'Trinidad & Tobago') {
            d['Country'] = 'Trinidad and Tobago'
          } else if (d['Country'] == 'Saint Kitts & Nevis') {
            d['Country'] = 'Saint Kitts and Nevis'
          }

          d['GDP ($ per capita)'] = Number(d['GDP ($ per capita)']);
          let reg = d['Region'];
          if (['ASIA (EX. NEAR EAST)', 'NEAR EAST', 'C.W. OF IND. STATES'].includes(d['Region'].trim())) {
            reg = 'ASIA';
          } else if (["EASTERN EUROPE", "WESTERN EUROPE", 'BALTICS'].includes(d['Region'].trim())) {
            reg = 'EUROPE';
          } else if (["SUB-SAHARAN AFRICA", "NORTHERN AFRICA"].includes(d['Region'].trim())) {
            reg = 'AFRICA';
          }
          d['Region'] = reg;

        });
        let regions = gdp_data.map(d => d['Region']);

        let gdpGroup = Object.fromEntries(d3.group(gdp_data, d => d.Country));

        let mbtiGroup = Object.fromEntries(d3.group(mbti_data, d => d.Country));
        console.log(mbtiGroup);

        // list of mbti countries only
        let mbti_countries = mbti_data.map(d => d['Country']);

        // group countries by mbti
        let mbtiByCountryData = {};
        mbti_keys.forEach((m, i) => {
          mbti_countries.forEach((c, i) => {
            if (!(m in mbtiByCountryData)) {
              mbtiByCountryData[m] = [];
            };
            let countryKey = {};
            countryKey[c] = mbtiGroup[c][0][m];
            mbtiByCountryData[m].push(countryKey);
          });
        });

        mbti_countries.forEach((c, i) => {
          if (c in gdpGroup) {
            mbtiGroup[c][0].GDP = gdpGroup[c][0]['GDP ($ per capita)'];
          }
        });

        console.log(happiness_data);
        // First Visualization
        var countries = topojson.feature(world, world.objects.countries);
        var countriesMesh = topojson.mesh(world, world.objects.countries);
        var projection1 = d3.geoEquirectangular()
          .fitSize([mapWidth1, mapHeight1], countries);
        var path = d3.geoPath().projection(projection1);

        happiness_data.forEach( (d, i) => {
          d['country'] = (d['Country name'].trim());
          if (d['country'] == 'United States') {
            d['country'] = 'United States of America'
          };
          d['happiness'] = Number(d['Healthy life expectancy']);
        });

        let happinessGroup = Object.fromEntries(d3.group(happiness_data, d => d.country));
        console.log(happinessGroup);

        let happiness_countries = happiness_data.map(d => d['country']);

        happiness_countries.forEach((c, i) => {
          happiness_countries[c] = Number(happinessGroup[c][0]['Healthy life expectancy']);
        })
        console.log(happiness_countries);

        let happinessExtent = d3.extent(Object.entries(happinessGroup), ([k, v]) => happinessGroup[k][0]['Healthy life expectancy']);
        console.log(happinessExtent);

        const colorScale1 = d3.scaleSequential(d3.interpolate("red", "yellow"))
          .domain(happinessExtent);

        map1.selectAll(".countries").data(countries.features)
          .join("path")
          .attr("class", "countries")
          .attr("d", path)
          .style("fill", d => colorScale1(happiness_countries[d.properties.name]))
          // .on('mouseover', mouseEntersPlot )
          // .on('mouseout', mouseLeavesPlot );
        

        map1.append("path").datum(countriesMesh)
          .attr("class", "outline_countries")
          .attr("d", path);

        
        
        
        // let momesh =  map.append("path")
        //             .attr("class","mouseover outline")
        //             .attr("d", "");

        // d3.selectAll(".countries").on("mouseenter", mouseEntersPlot);
        // d3.selectAll(".countries").on("mouseout",  mouseLeavesPlot);

        // Second Visualization
        // y axis
        let gdpExtent = d3.extent(Object.entries(mbtiGroup), ([k, v]) => mbtiGroup[k][0]['GDP']);
        let gdpScale = d3.scaleLinear()
          .range([chartHeight2, 0])
          .domain([0, gdpExtent[1]]);

        let leftAxis = d3.axisLeft(gdpScale).tickFormat(d3.format('$.2s'));

        let leftGridlines = d3.axisLeft(gdpScale)
          .tickFormat('')
          .tickSize(-chartWidth2);

        svg2.append('g').attr('class', 'y axis')
          .attr("transform", `translate(${margin2.left},${margin2.top})`)
          .call(leftAxis);

        svg2.append('g').attr('class', 'y gridlines')
          .attr("transform", `translate(${margin2.left},${margin2.top})`)
          .call(leftGridlines);

        // x axis 
        let mbtiCountry = Object.keys(mbtiGroup);
        const countryScale = d3.scaleBand().domain(mbtiCountry).range([margin2.left, chartWidth2]).padding([0]);

        let bottomAxis = d3.axisBottom();
        const bottomAxisG = svg2.append("g")
          .attr('transform', `translate(${margin2.left - 10},${chartHeight2 - 40})`);

        // get final data mbtis
        const allKeys = Object.keys(mbtiByCountryData).sort();
        // var selectText = document.getElementById("selectSpecies");

        let current_mbti = 'ENTJ'
        var selectText = document.getElementById("mbtiSelect");

        // create buttons for each of the MBTI keys
        allKeys.forEach(d => {
          var img = document.createElement('img');
          img.src = "../images/" + d + ".png";
          let mbtiImage = document.getElementById('button-bar').appendChild(img);
          mbtiImage.id = d;
          mbtiImage.style.height = '150px';
          mbtiImage.style.width = '120px';

          d3.select("#" + d)
            .on("mouseover", function () {
              mbtiImage.style.cursor = "pointer";
              mbtiImage.style.width = "140";
              mbtiImage.style.height = "160";
            })
            .on("click", function () {
              current_mbti = d;
              updateBarsAnimated(d);
              d3.select(this).style("background-color", "#ccc");
              selectText.innerText = d;
            })
            .on("mouseout", function () {
              d3.select(this).style("background-color", "white");
              mbtiImage.style.width = "120";
              mbtiImage.style.height = "150";
            })
        })



        // const colorScale = d3.scaleOrdinal([`#46874f`, `#DB675B`, `#665adb`, `#b375bf`, `#b63e36`, `#b74a70`, `#946943`]);
        const colorScale = d3.scaleOrdinal(d3.schemeSet2);

        function updateBarsAnimated(mbtiKey) {
          const data = mbtiByCountryData[mbtiKey];

          data.sort((a, b) => d3.ascending(Object.entries(a)[0][1], Object.entries(b)[0][1]))

          // bottomAxisG.transition().call(bottomAxis);

          chartArea2.selectAll('rect.bar').data(data)
            .join(

              enter => enter.append('rect')
                .attr('class', 'bar')
                .attr('fill', d => (colorScale(gdpGroup[Object.entries(d)[0][0]][0].Region)))
                .attr("x", (d, i) => (chartWidth2 / mbtiCountry.length) * i)
                .attr("y", d => gdpScale(mbtiGroup[Object.entries(d)[0][0]][0].GDP))
                .attr("height", d => gdpScale(0) - gdpScale(mbtiGroup[Object.entries(d)[0][0]][0].GDP))
                .attr("width", countryScale.bandwidth())
                .attr("mbti", d => Object.entries(d)[0][1])
                .attr("country", d => Object.entries(d)[0][0])
                .attr('region', d => (gdpGroup[Object.entries(d)[0][0]][0].Region))
                .attr("gdp", d => mbtiGroup[Object.entries(d)[0][0]][0].GDP)
                .attr('mbti_key', mbtiKey)
                .attr("opacity", 0)
                .call(enter => enter.transition().attr("opacity", 1)),

              update => update.call(update => update.transition()
                .attr("x", (d, i) => (chartWidth2 / mbtiCountry.length) * i)
                .attr('fill', d => (colorScale(gdpGroup[Object.entries(d)[0][0]][0].Region)))
                .attr("y", d => gdpScale(mbtiGroup[Object.entries(d)[0][0]][0].GDP))
                .attr("mbti", d => Object.entries(d)[0][1])
                .attr("country", d => Object.entries(d)[0][0])
                .attr('mbti_key', mbtiKey)
                .attr('region', d => (gdpGroup[Object.entries(d)[0][0]][0].Region))
                .attr("gdp", d => mbtiGroup[Object.entries(d)[0][0]][0].GDP).attr("height", d => gdpScale(0) - gdpScale(mbtiGroup[Object.entries(d)[0][0]][0].GDP))
                .attr("width", countryScale.bandwidth())),

              exit => exit.call(exit => exit.transition().attr("opacity", 0).remove())
            );
        }
        chartArea2.raise();

        updateBarsAnimated(current_mbti);


        // x axis
        svg2.append("text")
          .attr("class", "x label")
          .attr("text-anchor", "end")
          .style("font-size", 15)
          .attr("x", (width2 / 2) + 130)
          .attr("y", height2)
          .text("Selected MBTI Distribution Ranking");

        //  y axis
        svg2.append("text")
          .attr("class", "y label")
          .attr("text-anchor", "end")
          .attr("x", (-height2 / 2) + 19)
          .attr("y", 10)
          .attr("dy", ".75em")
          .attr("transform", "rotate(-90)")
          .text("GDP");

        let mouseover = svg2.append('g')
          .attr('class', 'mouseover')
          .attr('transform', `translate(${margin2.left}, ${margin2.top})`);

        function stringLen(str) {
          const dummy = mouseover.append('text').attr('class', 'dummytext').attr('visibility', 'hidden');
          dummy.text(str);
          let len = dummy.node().getComputedTextLength();
          dummy.remove();
          return len;
        }

        const info = mouseover.append('rect').attr('class', 'info')
          .attr('x', 0).attr('y', 0)
          .attr('rx', 5).attr('ry', 5)
          .attr('height', 53);

        const textbox = mouseover.append('g').attr('transform', "translate(5,5)").style('font-size', '10pt');

        let bars = chartArea2.selectAll('rect.bar');

        function updateMouseover(dat) {
          textbox.html('');

          let d = mbtiGroup[Object.entries(dat)[0][0]][0];
          let country = `Country: ${d['Country']}`;
          let gdp = `GDP per capita ($): $${d['GDP'].toString()}`;
          let mbti = `${current_mbti} percentage: ${(d[current_mbti] * 100).toFixed(2)}%`;

          let maxWidth = Math.max(stringLen(country), stringLen(gdp), stringLen(mbti));
          info.attr('width', maxWidth * 1.1);

          textbox.append('text').text(country)
            .attr('x', 0).attr('y', 10);
          textbox.append("text").text(gdp)
            .attr("x", 0).attr("y", 25);
          textbox.append("text").text(mbti)
            .attr("x", 0).attr("y", 40);

        };

        bars.on('mouseover', function (d) {
          // console.log(Object.entries(d3.select(this).datum())[0]);
          d3.select(this)
            .transition().duration(100)
            .attr('stroke-width', 1)
            .attr('stroke', 'steelBlue')
            .style('cursor', 'pointer');

          mouseover.attr('visibility', '');
          updateMouseover(d3.select(this).datum());
        });

        bars.on('mouseout', function () {
          mouseover.attr('visibility', 'hidden');

          d3.select(this)
            .transition().duration(100)
            .attr('stroke-width', 0);
        });


      }
      requestData();
    </script>
    </p>
</body>
</div>

</html>